Destructuring Arrays - 
- a way of turning an array into individual variables
Ex: const arr = [2, 3, 4]
const [x, y, z] = arr; // returns 2 3 4
- doesnt affect the original array in any way

- can take only part of the array if necessary. will take from array in order
- if you want certain elements, skip anything you dont needed
Ex: const [x, , z] = arr; // returns 2 4

- can create variables for nested arrays
Ex: const nested = [2, 3, [4, 5]]
const [x, y, z] = nested // returns 2 3 [4, 5]
const [x, y, [a, b]] = nested // returns 2 3 4 5

- you can set default values to variables you are making via Destructuring
Ex: const [k = 1, l = 1, m = 1] = [8, 9];
console.log(k, l, m); //returns 8 9 1
- helpful for when you arent sure the length of the array 

Destructuring Objects - 
- way of turning objects into variables
- order doesnt matter when destructuring objects
- names in destructuring must match name in object
Ex: const example = {
  ricky: 'aguayo',
  bibi: 'aguayo',
  monica: 'grotjan',
  puppies: {
    first: 'tommy',
    second: 'fiona',
    third: 'oliver',
  }
}
const {ricky, bibi, monica} = example;
- returns key as variable name and value as variable value

- can rename variables
Ex: const {ricky: middle, bibi: youngest, monica: oldest} = example
- returns same values with new variable names

- sets default values like arrays
Ex: {scott = [], monica: buttergut = []} = example
- returns [] 'grotjan'

- can bring out nested objects
const {puppies: {first} } = example
- returns 'tommy'

Spread Operator - 
- used to bring in ALL values from an iterable source (and objects as of ES2018)
- Iterable - arrays, strings, maps, sets. NOT objects
- can only be used when building a new array or passing values into a function
Ex: const arr1 = [1, 2, 3]
const arr2 = [...arr1, 4, 5] // returns [1, 2, 3, 4, 5]
- can be used to pull elements out of an array individually
Ex: console.log(...arr2) //  returns 1, 2, 3, 4, 5
- this doesnt manipulate original array. this adds onto a new/existing array
- unlike destructuring, the spread operator does not create new values
  
String Ex: const str = 'Ricky'
  const letters = [...str] // returns ['R', 'i', 'c', 'k', 'y']

- create a shallow copy of an array:
Ex: const copyArr = [...arr1] // returns copy of arr1 under new variable name

- merge multiple arrays:
Ex: const mergedArr = [...arr1, ...arr2] // returns one array with all the values from arr1 and arr2

- With objects, the process is the same but with curly braces
Ex: const newObj = {...example} // returns everything in the example object and makes a copy object named newObj

Rest  - 
- opposite of spread operator. collects any unused variables from a destructuring assignment
- same syntax as a spread operator but is on the left side of the assignment operator. Spread will always be on the right
Ex: const [a, b, ...others] = [1, 2, 3, 4, 5]
  - returns 1, 2, [3, 4, 5]

- both spread and rest can be used at the same time
- rest element used must be the last element in array, otherwise and error is thrown
- will not account for skipped elements
- can only ever be one rest instance per destructuring assignment
- can also be used in paramaters for functions

Short Circuiting with logical operators (&& and ||) - 
- ignores and does not evaluate the rest of values after it finds what its looking for
- can be used with any data type
- can return any data type

- OR (||) - 
  - finds and returns first truthy value.
  Ex: console.log(3 || 'ricky') //returns 3
      console.log('' || 'ricky') //returns 'ricky'
  - If neither values are truthy, js will return the last value
  Ex: console.log(undefined || null) // returns null
  - Can be used in place of ternary operators (to set default values)
  - keep in mind that 0 is a falsy value. so it will be skipped over even when 0 may be needed

- AND (&&) - 
  - finds and returns first falsy value
  Ex: console.log(0 && 'Ricky') // returns 0 
  - If neither values are falsy, js will return the last value
  Ex: console.log('Ricky' && 11) // returns 11
  - Can be used in place of if statements. (to execute code if first operand is true)

Nullish Coalescing (??) - 
- Nullish values: null, undefined
- works like || but ?? will only short circuit when it finds a nullish value
- 0 and '' will not short circuit when a ?? is present
- this fixes having a 0 as a value when using ||

Logical assignment operators - 
- shorthand for short circuiting
OR - rest1.numGuests ||= 10
NULLISH - rest1.numGuests ??= 10 //helps if value needed is 0 or ''
AND - rest1.numGuests &&= 10

For of loop - 
- used to iterate through a list and returns individual item from array
Ex: for(const item of menu){
  console.log(item) //returns each item in array
}
- to extract index from a for of loop, .entries() must be used on array
- for(const item of menu.entries()) console.log(item) // returns [index, value]
- can be used with destructuring

Enhanced Object Literals - 
1. an object outside another can be used inside the other by just writing the object name
Ex: const obj1 = {
  name: 'ricky'
}

const obj2 = {
  age: 31,
  obj1, //this brings in obj1
  favColor: 'blue'
}

2. can omit function keyword when writing methods
Ex: const obj1 = {
  printName: function(name) {
    console.log(name)
  },

  printName2(name) {
    console.log(name)
  }
}
- both work the same

3. can compute property names without writing them out
const weekend = ['sat', 'sun']
const obj1  = {
  [weekend[0]]: 'saturday',
  [weekend[1]]: 'sunday',
}'

Optional Chaining - 
- returns undefined (instead of throwing error) if a part of an object comes back undefined
- works with nullish values
Ex: restaurant.openingHours.mon.open // returns error because mon isnt in object therefore there is no open
    restaurant.openingHours.mon?.open // returns undefined because of the '?.'
    - this is saying that if this doesnt exist, return undefined, not an error
- can have multiple optional chaining
- can check if methods exist

Object.keys()
- returns keys from an object as an array

Object.values()
- returns values from an object as an array

Object.entries()
- returns entire object as arrays in an array. each key/value pair is an array

Sets - 
- collection of unique values
- iterable (can be used in for of loop)
- iterable must be passed in when creating a set. Ex: const newSet = new Set([])
- can never have any duplicates. if there are duplicates, the set will throw the duplicates away
- can hold any data structure
- like arrays, but sets have unique values and order is irrelevant

- .size - returns number of unique values. (like .length for arrays)
- .has() - returns boolean if value is in the set. (like .includes for arrays)
- .add() - adds value to set
- .delete() - deletes value from set
- .clear() - clears entire set

- sets do not have indexes or order
- data cannot be retrieved from a set. sets are made to see if a value is present
- if data needs to be retrieved, use an array
- sets can be turned into arrays using spread. 
Ex: const staffSet = [...new Set(staff)];

- not really used to replace arrays. used to compliment arrays when unique values are needed

Maps - 
- data structure where we can map values to keys
- like objects. both have key/value pairs.
- maps can have any data type as a key (including arrays and objects)

- .set(key, value) - adds to map (like .add() for sets)
  - returns updated map
  - this allows to chain set methods
- .get(key) - returns value of passed in key
- .has(key) - returns boolean
- .delete(key) - deletes both key and value
- .clear() - clears entire map

- another way of populating a map is by passing in key/value pairs as arrays inside a containing array. this eliminates the need of the .set() method
- objects can be converted to maps using Object.entries(object)
- maps also have access to the .entries(), .keys() and .values() methods

Arrays vs Sets
- use an array or set when you only need a value and no descriptor (key)

- Arrays:
  - use when you need ordered list of values (can contain duplicates)
  - use when you need to manipulate data

- Sets:
  - use when you need to work with unique values
  - use when high performance is really important
  - use to remove duplicates from arrays

Objects vs Maps
- use when a key/value pair is needed

Objects:
- more traditional key/value store
- easier to write and access data with [] and .
- use when you need to include functions(methods)
- use when working with JSON (can convert to map)

Maps:
- better performance
- keys can have any data type
- easy to iterate
- easy to compute size
- use when you simply need to map keys to values
- use when you need keys that are not strings

//////////////////STRINGS////////////////////

String Methods:
- methods are usually reserved for arrays and objects, but in js strings can use them too
  - this is because behind the scenes, js will transform the string into a string object when methods are used
  - new String('ricky') <-- string object
  - the string object is then converted back to a string once the operation is done
- all string methods are case sensitive

- .indexOf(value) - finds first occurence of value in string
- .lastIndexOf(value) - finds last occurence of value in string
- .slice(x, y)
  - x - index of where extraction for substring begins
  - y - index of where extractions for substring ends
  - can use indexOf and lastIndexOf combined with slice to find certain words
    - airline.slice(0, airline.indexOf(' '))
  - using negative numbers starts slicing from the end
    - airline.slice(-2) //returns 'al'
- .toLowerCase() - converts string to all lower case letters
- .toUpperCase() - converts string to all upper case letters
- .trim() - remmoves first and last white space from string
- .replace(x, y) - 
  - x - letter or term that will be replaced
  - y - letter or term that will be used to replace x
  - this only works on the first instance
- .replaceAll(x, y) - same as .replace() but replaces all instances
  - can also use regex to achieve the same
  - Ex: announcement.replace(/money/g, 'booty')
- .includes(value) - checks to see if value is in string. returns boolean
- .startsWith(value) - checks to see if string starts with value. returns boolean
- .includes(value) - checks to see if string ends with value. returns boolean
- .split(divider) - splits up string into an array based on divider
- .join(divider) - joins an array into a string with divider
- .padStart(x, y) - adds characters to beginning of string to fulfill total length
- .padEnd(x, y) - adds characters to end of string to fulfill total length
  - x - total length of string
  - y - what character should be used to pad
  - if you dont specify a character, it will default to spaces
- .repeat(x) - repeats string x number of times